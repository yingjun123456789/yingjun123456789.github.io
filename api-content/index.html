{"posts":[{"title":"JQuery","content":"今日内容： 1. JQuery 高级 1. 动画 2. 遍历 3. 事件绑定 4. 案例 5. 插件 JQuery 高级 1. 动画 1. 三种方式显示和隐藏元素 1. 默认显示和隐藏方式 1. show([speed,[easing],[fn]]) 1. 参数： 1. speed：动画的速度。三个预定义的值(&quot;slow&quot;,&quot;normal&quot;, &quot;fast&quot;)或表示动画时长的毫秒数值(如：1000) 2. easing：用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot; * swing：动画执行时效果是 先慢，中间快，最后又慢 * linear：动画执行时速度是匀速的 3. fn：在动画完成时执行的函数，每个元素执行一次。 2. hide([speed,[easing],[fn]]) 3. toggle([speed],[easing],[fn]) 2. 滑动显示和隐藏方式 1. slideDown([speed],[easing],[fn]) 2. slideUp([speed,[easing],[fn]]) 3. slideToggle([speed],[easing],[fn]) 3. 淡入淡出显示和隐藏方式 1. fadeIn([speed],[easing],[fn]) 2. fadeOut([speed],[easing],[fn]) 3. fadeToggle([speed,[easing],[fn]]) 2. 遍历 1. js的遍历方式 * for(初始化值;循环结束条件;步长) 2. jq的遍历方式 1. jq对象.each(callback) 1. 语法： jquery对象.each(function(index,element){}); * index:就是元素在集合中的索引 * element：就是集合中的每一个元素对象 * this：集合中的每一个元素对象 2. 回调函数返回值： * true:如果当前function返回为false，则结束循环(break)。 * false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) 2. $.each(object, [callback]) 3. for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 3. 事件绑定 1. jquery标准的绑定方式 * jq对象.事件方法(回调函数)； * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 * 表单对象.submit();//让表单提交 2. on绑定事件/off解除绑定 * jq对象.on(&quot;事件名称&quot;,回调函数) * jq对象.off(&quot;事件名称&quot;) * 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 3. 事件切换：toggle * jq对象.toggle(fn1,fn2...) * 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2..... * 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 &lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 4. 案例 1. 广告显示和隐藏 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;广告的自动显示与隐藏&lt;/title&gt; &lt;style&gt; #content{width:100%;height:500px;background:#999} &lt;/style&gt; &lt;!--引入jquery--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 需求： 1. 当页面加载完，3秒后。自动显示广告 2. 广告显示5秒后，自动消失。 分析： 1. 使用定时器来完成。setTimeout (执行一次定时器) 2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display 3. 使用 show/hide方法来完成广告的显示 */ //入口函数，在页面加载完成之后，定义定时器，调用这两个方法 $(function () { //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); }); //显示广告 function adShow() { //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); } //隐藏广告 function adHide() { //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); } ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ &lt;!-- 下方正文部分 --&gt; &lt;div id=&quot;content&quot;&gt; 正文部分 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. 抽奖 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;jquery案例之抽奖&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script language='javascript' type='text/javascript'&gt; /* 分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 */ var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () { // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); },20); }); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () { //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); }); }); ​ ​ ​ ​ &lt;/head&gt; &lt;body&gt; &lt;!-- 小像框 --&gt; &lt;div style=&quot;border-style:dotted;width:160px;height:100px&quot;&gt; &lt;img id=&quot;img1ID&quot; src=&quot;../img/man00.jpg&quot; style=&quot;width:160px;height:100px&quot;/&gt; &lt;/div&gt; &lt;!-- 大像框 --&gt; &lt;div style=&quot;border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px&quot;&gt; &lt;img id=&quot;img2ID&quot; src=&quot;../img/man00.jpg&quot; width=&quot;800px&quot; height=&quot;500px&quot;/&gt; &lt;/div&gt; &lt;!-- 开始按钮 --&gt; &lt;input id=&quot;startID&quot; type=&quot;button&quot; value=&quot;点击开始&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;!-- 停止按钮 --&gt; &lt;input id=&quot;stopID&quot; type=&quot;button&quot; value=&quot;点击停止&quot; style=&quot;width:150px;height:150px;font-size:22px&quot;&gt; &lt;/body&gt; &lt;/html&gt; 5. 插件：增强JQuery的功能 1. 实现方式： 1. $.fn.extend(object) * 增强通过Jquery获取的对象的功能 $(&quot;#id&quot;) 2. $.extend(object) * 增强JQeury对象自身的功能 $/jQuery ","link":"https://yingjun123456789.github.io/post/jquery/"},{"title":"安装Docker","content":"1、yum 包更新到最新 yum update 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2 3、 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce 5、 查看docker版本，验证是否验证成功 docker -v ","link":"https://yingjun123456789.github.io/post/an-zhuang-docker/"},{"title":"Mybatis","content":"Mybatis-9.28 环境： JDK1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。 最好的方式：看官网文档； 1、简介 1.1、什么是Mybatis MyBatis 是一款优秀的持久层框架 它支持定制化 SQL、存储过程以及高级映射。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github。 如何获得Mybatis？ maven仓库： &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; Github ： https://github.com/mybatis/mybatis-3/releases 中文文档：https://mybatis.org/mybatis-3/zh/index.html 1.2、持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io文件持久化。 生活：冷藏. 罐头。 为什么需要需要持久化？ 有一些对象，不能让他丢掉。 内存太贵了 1.3、持久层 Dao层，Service层，Controller层…. 完成持久化工作的代码块 层界限十分明显。 1.4 为什么需要Mybatis？ 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。 技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 最重要的一点：使用的人多！ Spring SpringMVC SpringBoot 2、第一个Mybatis程序 思路：搭建环境--&gt;导入Mybatis--&gt;编写代码--&gt;测试！ 2.1、搭建环境 搭建数据库 CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'狂神','123456'), (2,'张三','123456'), (3,'李四','123890') 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.2、创建一个模块 编写mybatis的核心配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;!--configuration核心配置文件--&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 编写mybatis工具类 //sqlSessionFactory --&gt; sqlSession public class MybatisUtils { private static SqlSessionFactory sqlSessionFactory; static{ try { //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。 // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 2.3、编写代码 实体类 package com.kuang.pojo; //实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name='&quot; + name + '\\'' + &quot;, pwd='&quot; + pwd + '\\'' + '}'; } } Dao接口 public interface UserDao { List&lt;User&gt; getUserList(); } 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件. &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt; &lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt; &lt;!--select查询语句--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;/mapper&gt; 2.4、测试 注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册 mappers junit测试 @Test public void test(){ //第一步：获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭SqlSession sqlSession.close(); } 你们可以能会遇到的问题： 配置文件没有注册 绑定接口错误。 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD 1、namespace namespace中的包名要和 Dao/mapper 接口的包名一致！ 2、select 选择，查询语句; id : 就是对应的namespace中的方法名； resultType：Sql语句执行的返回值！ parameterType ： 参数类型！ 编写接口 //根据ID查询用户 User getUserById(int id); 编写对应的mapper中的sql语句 &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from mybatis.user where id = #{id} &lt;/select&gt; 测试 @Test public void getUserById() { SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close(); } 3、Insert &lt;!--对象中的属性，可以直接取出来--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into mybatis.user (id, name, pwd) values (#{id},#{name},#{pwd}); &lt;/insert&gt; 4、update &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update mybatis.user set name=#{name},pwd=#{pwd} where id = #{id} ; &lt;/update&gt; 5、Delete &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #{id}; &lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范！ NullPointerException，没有注册到资源! 输出的xml文件中存在中文乱码问题！ maven资源没有导出问题！ 7、万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ //万能的Map int addUser2(Map&lt;String,Object&gt; map); &lt;!--对象中的属性，可以直接取出来 传递map的key--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id, pwd) values (#{userid},#{passWord}); &lt;/insert&gt; @Test public void addUser2(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,5); map.put(&quot;passWord&quot;,&quot;2222333&quot;); mapper.addUser2(map); sqlSession.close(); } Map传递参数，直接在sql中取出key即可！ 【parameterType=&quot;map&quot;】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=&quot;Object&quot;】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8、思考题 模糊查询怎么写？ Java代码执行的时候，传递通配符 % % List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符！ select * from mybatis.user where name like &quot;%&quot;#{value}&quot;%&quot; 4、配置解析 1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） 2、环境配置（environments） MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED 3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】 编写一个配置文件 db.properties driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8 username=root password=123456 在核心配置文件中映入 &lt;!--引入外部配置文件--&gt; &lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;pwd&quot; value=&quot;11111&quot;/&gt; &lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ 4、类型别名（typeAliases） 类型别名是为 Java 类型设置一个短的名字。‘ 存在的意义仅在于用来减少类完全限定名的冗余。 &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt; &lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！ &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt; &lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解 @Alias(&quot;user&quot;) public class User {} 5、设置 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins插件 mybatis-generator-core mybatis-plus 通用mapper 7、映射器（mappers） MapperRegistry：注册绑定我们的Mapper文件； 方式一： 【推荐使用】 &lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; 方式二：使用class文件绑定注册 &lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt; &lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 &lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt; &lt;mappers&gt; &lt;package name=&quot;com.kuang.dao&quot;/&gt; &lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！ 8、生命周期和作用域 生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为 ：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题 1、 问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } 测试出现问题 // select * from mybatis.user where id = #{id} //类型处理器 // select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 &lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select id,name,pwd as password from mybatis.user where id = #{id} &lt;/select&gt; 2、resultMap 结果集映射 id name pwd id name password &lt;!--结果集映射--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #{id} &lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 如果世界总是这么简单就好了。 6、日志 6.1、日志工厂 如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout 、debug 现在：日志工厂！ SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在Mybatis中具体使用那个一日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt; &lt;/settings&gt; 6.2、Log4j 什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; log4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file = org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt; &lt;/settings&gt; Log4j的使用！，直接测试运行刚才的查询 简单使用 在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 logger.info(&quot;info:进入了testLog4j&quot;); logger.debug(&quot;debug:进入了testLog4j&quot;); logger.error(&quot;error:进入了testLog4j&quot;); 7、分页 思考：为什么要分页？ 减少数据的处理量 7.1、使用Limit分页 语法：SELECT * from user limit startIndex,pageSize; SELECT * from user limit 3; #[0,n] 使用Mybatis实现分页，核心SQL 接口 //分页 List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml &lt;!--//分页--&gt; &lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #{startIndex},#{pageSize} &lt;/select&gt; 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,1); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 7.2、RowBounds分页 不再使用SQL实现分页 接口 //分页2 List&lt;User&gt; getUserByRowBounds(); mapper.xml &lt;!--分页2--&gt; &lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user &lt;/select&gt; 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //RowBounds实现 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层面实现分页 List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kuang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 7.3、分页插件 了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！ 8、使用注解开发 8.1、面向接口编程 - 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程 - 根本原因 : 解耦 , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好 - 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了； - 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 - 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。 - 接口的本身反映了系统设计人员对系统的抽象理解。 - 接口应有两类： - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）； - 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 - 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 . - 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 . - 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 8.2、使用注解开发 注解在接口上实现 @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); 需要再核心配置文件中绑定接口！ &lt;!--绑定接口--&gt; &lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt; &lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ 8.3、CRUD 我们可以在工具类创建的时候实现自动提交事务！ public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口，增加注解 public interface UserMapper { @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); // 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解 @Select(&quot;select * from user where id = #{id}&quot;) User getUserByID(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values (#{id},#{name},#{password})&quot;) int addUser(User user); @Update(&quot;update user set name=#{name},pwd=#{password} where id = #{id}&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #{uid}&quot;) int deleteUser(@Param(&quot;uid&quot;) int id); } 测试类 【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】 关于@Param() 注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！ #{} ${} 区别 9、Lombok Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; 在实体类上加注解即可！ @Data @AllArgsConstructor @NoArgsConstructor @Getter and @Setter @FieldNameConstants @ToString @EqualsAndHashCode @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger @Data @Builder @Singular @Delegate @Value @Accessors @Wither @SneakyThrows 说明： @Data：无参构造，get、set、tostring、hashcode，equals @AllArgsConstructor @NoArgsConstructor @EqualsAndHashCode @ToString @Getter 10、多对一处理 多对一： 多个学生，对应一个老师 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】 SQL： CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`, `name`) VALUES (1, '秦老师'); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('1', '小明', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('2', '小红', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('3', '小张', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('4', '小李', '1'); INSERT INTO `student` (`id`, `name`, `tid`) VALUES ('5', '小王', '1'); 测试环境搭建 导入lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】 测试查询是否能够成功！ 按照查询嵌套处理 &lt;!-- 思路: 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection --&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id = #{id} &lt;/select&gt; 按照结果嵌套处理 &lt;!--按照结果嵌套处理--&gt; &lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id; &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 回顾Mysql 多对一查询方式： 子查询 联表查询 11、一对多处理 比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系! 环境搭建 环境搭建，和刚才一样 实体类 @Data public class Student { private int id; private String name; private int tid; } @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students; } 按照结果嵌套处理 &lt;!--按结果嵌套查询--&gt; &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #{tid} &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection javaType=&quot;&quot; 指定属性的类型！ 集合中的泛型信息，我们使用ofType获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 按照查询嵌套处理 &lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from mybatis.teacher where id = #{tid} &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #{tid} &lt;/select&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ 12、动态 SQL 什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句 利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。 if choose (when, otherwise) trim (where, set) foreach 搭建环境 CREATE TABLE `blog` ( `id` varchar(50) NOT NULL COMMENT '博客id', `title` varchar(100) NOT NULL COMMENT '博客标题', `author` varchar(30) NOT NULL COMMENT '博客作者', `create_time` datetime NOT NULL COMMENT '创建时间', `views` int(30) NOT NULL COMMENT '浏览量' ) ENGINE=InnoDB DEFAULT CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 @Data public class Blog { private int id; private String title; private String author; private Date createTime; private int views; } 编写实体类对应Mapper接口 和 Mapper.XML文件 IF &lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/select&gt; choose (when, otherwise) &lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #{title} &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #{author} &lt;/when&gt; &lt;otherwise&gt; and views = #{views} &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; trim (where,set) select * from mybatis.blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/where&gt; &lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update mybatis.blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title}, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #{author} &lt;/if&gt; &lt;/set&gt; where id = #{id} &lt;/update&gt; 所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码 if where ， set ， choose ，when SQL片段 有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 &lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #{title} &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #{author} &lt;/if&gt; &lt;/sql&gt; 在需要使用的地方使用Include标签引用即可 &lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt; &lt;/select&gt; 注意事项： 最好基于单表来定义SQL片段！ 不要存在where标签 Foreach select * from user where 1=1 and &lt;foreach item=&quot;id&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; (id=1 or id=2 or id=3) &lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map ， 这map中可以存在一个集合！ --&gt; &lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #{id} &lt;/foreach&gt; &lt;/where&gt; &lt;/select&gt; 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！ 13、缓存 （了解） 13.1、简介 查询 ： 连接数据库 ，耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--&gt; 内存 ： 缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。【可以使用缓存】 13.2、Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.3、一级缓存 一级缓存也叫本地缓存： SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试步骤： 开启日志！ 测试在一个Sesion中查询两次相同记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map。 13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 &lt;!--显示的开启全局缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 &lt;!--在当前Mapper.xml中使用二级缓存--&gt; &lt;cache/&gt; 也可以自定义参数 &lt;!--在当前Mapper.xml中使用二级缓存--&gt; &lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题:我们需要将实体类序列化！否则就会报错！ Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！ 13.5、缓存原理 13.6、自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用ehcache，先要导包！ &lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; 在mapper中指定使用我们的ehcache缓存实现！ &lt;!--在当前Mapper.xml中使用二级缓存--&gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; ehcache.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt; &lt;/ehcache&gt; Redis数据库来做缓存！ K-V 练习：29道练习题实战！ ","link":"https://yingjun123456789.github.io/post/mybatis/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://yingjun123456789.github.io/post/hello-gridea/"}]}